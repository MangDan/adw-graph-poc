[{"/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/main.js":"1","/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/App.vue":"2","/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/plugins/vuetify.js":"3","/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/components/HelloWorld.vue":"4","/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/plugins/blitzboard/blitzboard.js":"5"},{"size":186,"mtime":1653912047143,"results":"6","hashOfConfig":"7"},{"size":1225,"mtime":1653912492355,"results":"8","hashOfConfig":"7"},{"size":121,"mtime":1653910832777,"results":"9","hashOfConfig":"7"},{"size":3463,"mtime":1653910832778,"results":"10","hashOfConfig":"7"},{"size":45229,"mtime":1653838682684,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1yv2nli",{"filePath":"15","messages":"16","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"23","messages":"24","errorCount":30,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25"},"/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/main.js",[],[],"/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/App.vue",["26"],"<template>\n  <v-app>\n    <v-app-bar\n      app\n      color=\"primary\"\n      dark\n    >\n      <div class=\"d-flex align-center\">\n        <v-img\n          alt=\"Vuetify Logo\"\n          class=\"shrink mr-2\"\n          contain\n          src=\"https://cdn.vuetifyjs.com/images/logos/vuetify-logo-dark.png\"\n          transition=\"scale-transition\"\n          width=\"40\"\n        />\n\n        <v-img\n          alt=\"Vuetify Name\"\n          class=\"shrink mt-1 hidden-sm-and-down\"\n          contain\n          min-width=\"100\"\n          src=\"https://cdn.vuetifyjs.com/images/logos/vuetify-name-dark.png\"\n          width=\"100\"\n        />\n      </div>\n\n      <v-spacer></v-spacer>\n\n      <v-btn\n        href=\"https://github.com/vuetifyjs/vuetify/releases/latest\"\n        target=\"_blank\"\n        text\n      >\n        <span class=\"mr-2\">Latest Release</span>\n        <v-icon>mdi-open-in-new</v-icon>\n      </v-btn>\n    </v-app-bar>\n\n    <v-main>\n      <HelloWorld/>\n    </v-main>\n  </v-app>\n</template>\n\n<script>\nimport HelloWorld from './components/HelloWorld';\nimport Blitzboard from './plugins/blitzboard/blitzboard';\n\nexport default {\n  name: 'App',\n\n  components: {\n    HelloWorld,\n    Blitzboard,\n  },\n\n  data: () => ({\n    //\n  }),\n};\n</script>\n","/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/plugins/vuetify.js",[],"/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/components/HelloWorld.vue",[],[],"/Users/dankim/Programming/Code/vue-workspace/adw-graph-poc/src/plugins/blitzboard/blitzboard.js",["27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56"],"'use strict';\n\nconst q = document.querySelector.bind(document);\nconst qa = document.querySelectorAll.bind(document);\n\nclass DuplicateNodeError extends Error {\n  constructor(nodes) {\n    super(`Duplicate node: ${nodes.map(n => n.id).join(', ')}`);\n    this.name = \"NodeDuplicationError\";\n    this.nodes = nodes;\n  }\n}\n\nclass Blitzboard {\n  static fondLoaded = false;\n  static defaultConfig = {\n    doubleClickWait: 200,\n    node: {\n      caption: ['id'],\n      defaultIcon: true,\n      thumbnail: 'thumbnail',\n      saturation: '100%',\n      brightness: '37%',\n    },\n    edge: {\n      caption: ['label'],\n      length: {\n        distance: 'value',\n      },\n      width: {\n        flow: 'throughput',\n      },\n      saturation: '0%',\n      brightness: '62%',\n    },\n    zoom: { \n      max: 3.0,\n      min: 0.25,\n    },\n    layoutSettings: {\n      time_from: 'from',\n      time_to: 'to',\n      lng: 'lng',\n      lat: 'lat'\n    },\n    extraOptions: {\n    }\n  };\n  static iconPrefixes = ['fa-solid:', 'ion:', 'bx:bx-', 'gridicons:', 'akar-icons:'];\n  static iconSizeCoef = 1.5;\n  static minScaleOnMap = 0.3;\n  static maxScaleOnMap = 1.0;\n  static mapContainerId = 'map';\n  static nodeTemplate = {\n    id: null,\n    labels: [],\n    properties: {}\n  }\n  static edgeTemplate = {\n    from: null,\n    to: null,\n    direction: '->',\n    labels: [],\n    properties: {}\n  }\n\n  static loadedIcons = {};\n  \n  static renderedColors = {};\n  \n  constructor(container) {\n    this.container = container;\n    this.nodeColorMap = {};\n    this.expandedNodes = [];\n    this.nodeMap = {};\n    this.config = { node: {}, edge: {}};\n    this.nodeLineMap = {};\n    this.edgeMap = {};\n    this.edgeLineMap = {};\n    this.prevZoomPosition = null;\n    this.warnings = [];\n    \n    this.container.style.position = 'absolute';\n    \n    this.networkContainer = document.createElement('div');\n    this.networkContainer.style = `\n      height: 100%;\n      width: 100%;\n      top: 0;\n      left: 0;\n      position: absolute;\n      z-index: 2;\n    `;\n    \n    this.mapContainer = document.createElement('div');\n    this.mapContainer.style = `\n      height: 100%;\n      width: 100%;\n      top: 0;\n      left: 0;\n      position: absolute;\n      z-index: 1;\n    `;\n    this.map = null;\n\n    this.minTime = new Date(8640000000000000);\n    this.maxTime = new Date(-8640000000000000);\n    \n    this.prevMouseEvent= null;\n    this.timeScale = 1000;\n    this.dragging = false;\n    this.currentLatLng = null;\n    this.redrawTimer = null;\n    this.onNodeAdded = [];\n    this.onEdgeAdded = [];\n    this.onNodeFocused = [];\n    this.onEdgeFocused = [];\n    this.maxLine = 0;\n    this.scrollAnimationTimerId = null;\n    this.screen = document.createElement('div');\n    this.screenText = document.createElement('div');\n    this.screenText.style = `\n      font-size: 2rem;\n      background-color: rgba(255, 255, 255, 0.5);\n      padding: 10px;\n    `;\n    this.screen.appendChild(this.screenText);\n    this.screenText.innerText = \"Now loading...\";\n    this.screen.style = `\n      background-color: rgba(0, 0, 0, 0.3);\n      z-index: 3;\n      position: absolute;\n      height: 100%;\n      width: 100%;\n      display: none;\n      justify-content: center;\n      align-items: center;\n      font-size: 2rem;\n    `;\n    this.doubleClickTimer = null;\n    \n    let blitzboard = this;\n\n    container.appendChild(this.screen);\n    container.appendChild(this.networkContainer);\n    container.appendChild(this.mapContainer);\n\n    this.container.addEventListener('wheel', (e) => {\n      if(blitzboard.config.layout === 'map')\n      {\n        if((e.deltaY < 0 && blitzboard.map._zoom < blitzboard.map.getMaxZoom()) ||\n          (e.deltaY > 0 && blitzboard.map._zoom > blitzboard.map.getMinZoom()) ) {\n          if(!blitzboard.currentLatLng) {\n            blitzboard.currentLatLng = blitzboard.map.mouseEventToLatLng(e);\n          }\n          blitzboard.map.setZoomAround(blitzboard.currentLatLng, blitzboard.map._zoom - e.deltaY * 0.03, {animate: false});\n        }\n        let newScale = blitzboard.map._zoom / 12 + 0.4;\n        newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(newScale, Blitzboard.minScaleOnMap));\n        setTimeout( () => {\n          blitzboard.network.moveTo({scale: newScale});\n          blitzboard.updateNodeLocationOnMap();\n        }, 10);\n        blitzboard.map.invalidateSize();\n        e.preventDefault();\n        e.stopPropagation(); // Inhibit zoom on vis-network\n      }\n    }, true);\n\n    this.container.addEventListener('mouseout', (e) => {\n      blitzboard.prevMouseEvent = null;\n      blitzboard.dragging = false;\n    }, true);\n\n    this.container.addEventListener('mouseup', (e) => {\n      blitzboard.dragging = false;\n      blitzboard.prevMouseEvent = null;\n    }, true);\n\n    this.container.addEventListener('mousemove', (e) => {\n      if(blitzboard.dragging && blitzboard.config.layout === 'map' && blitzboard.prevMouseEvent) {\n        blitzboard.map.panBy([blitzboard.prevMouseEvent.x - e.x, blitzboard.prevMouseEvent.y - e.y], {animate: false});\n      }\n      blitzboard.prevMouseEvent = e;\n      blitzboard.currentLatLng = null;\n    }, true);\n\n    this.container.addEventListener('dblclick', (e) => {\n      if(blitzboard.config.layout === 'map') {\n        blitzboard.map.panTo(blitzboard.map.mouseEventToLatLng(e));\n      }\n    }, true);\n\n    this.container.addEventListener('mousedown', (e) => {\n      blitzboard.dragging = true;\n      blitzboard.prevMouseEvent = e;\n    }, true);\n  }\n\n  static blitzProxy = {\n    get: function(target, prop, receiver) {\n      if (prop === 'label') {\n        return target.labels[0];\n      }\n      if (!(prop in target) && prop in target.properties) {\n        return target.properties[prop][0]; \n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  }\n\n  getHexColors(colorStr) {\n    let computed = Blitzboard.renderedColors[colorStr];\n    if(computed) {\n      return computed;\n    }\n    let a = document.createElement('div');\n    a.style.color = colorStr;\n    let colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\\d+/g).map(function(a){ return parseInt(a,10); });\n    document.body.removeChild(a);\n    Blitzboard.renderedColors[colorStr] = colors;\n    return colors;\n  }\n  \n  hasNode(node_id) {\n    return !!this.nodeMap[node_id];\n  }\n  \n  hasEdge(from, to, label = null) {\n    for(let edge of this.graph.edges) {\n      if(edge.from === from && edge.to === to && (!label || edge.labels.includes(label)))\n        return true;\n    }\n    return false;\n  }\n  \n  getAllNodes(label = null) {\n    if(label)\n      return this.graph.nodes.filter(node => node.labels.includes(label)).map(node => this.getNode(node.id));\n    else\n      return this.graph.nodes.map(node => this.getNode(node.id));\n  }\n\n  getNode(node_id) {\n    return new Proxy(this.nodeMap[node_id], Blitzboard.blitzProxy);\n  }\n  \n  getEdge(edge_id) {\n    return new Proxy(this.edgeMap[edge_id], Blitzboard.blitzProxy);\n  }\n  \n  calcNodePosition(pgNode) {\n    let x, y, fixed, width;\n    if(this.config.layout === 'timeline' && this.timeInterval > 0) {\n      x = null;\n      fixed = false;\n      let fromProp = this.config.layoutSettings.time_from;\n      let toProp = this.config.layoutSettings.time_to;\n      let from = this.maxTime;\n      let to = this.minTime;\n\n      for (let prop of Object.keys(pgNode.properties)) {\n        if (prop === fromProp || prop === toProp) {\n          from = new Date(Math.min(from, new Date(pgNode.properties[prop][0])));\n          to = new Date(Math.max(to, new Date(pgNode.properties[prop][0])));\n        }\n      }\n    \n      if(from <= to) {\n        fixed = true;\n        let fromPosition = this.timeScale * (from.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;\n        let toPosition = this.timeScale * (to.getTime() - this.minTime.getTime()) * 1.0 / this.timeInterval - this.timeScale * 0.5;\n        x = (fromPosition + toPosition) / 2;\n        if(from === to) {\n          width = fromPosition - toPosition;\n        } else {\n          width = 25;\n        }\n      } else {\n        x = 0;\n      }\n    }\n    else {\n      if(this.config.layout == 'custom') {\n        if (pgNode.properties[this.config.layoutSettings.x] || pgNode.properties[this.config.layoutSettings.y]) {\n          x = parseInt(pgNode.properties[this.config.layoutSettings.x][0]);\n          y = parseInt(pgNode.properties[this.config.layoutSettings.y][0]);\n          fixed = true;\n        }\n      } else {\n        x = null;\n        y = null;\n        fixed = this.config.layout === 'hierarchical';\n        width = null;\n      }\n    }\n    \n    return {x, y, fixed, width};\n  }\n\n  retrieveThumbnailUrl(node) {\n    if(this.config.node.thumbnail) {\n      return node.properties[this.config.node.thumbnail]?.[0];\n    }\n    return null;\n  }\n\n  toVisNode(pgNode, props, extraOptions = null) {\n    const group = [...pgNode.labels].sort().join('_');\n    if(!this.nodeColorMap[group]) {\n      this.nodeColorMap[group] = getRandomColor(group, this.config.node.saturation, this.config.node.brightness);\n    }\n    \n    let x, y, fixed, width;\n    ({x, y, fixed, width} = this.calcNodePosition(pgNode));\n\n    let url = retrieveHttpUrl(pgNode);\n    let thumbnailUrl = this.retrieveThumbnailUrl(pgNode);\n    let expanded = this.expandedNodes.includes(pgNode.id);\n\n    let degree =  pgNode.properties['degree'];\n    let blitzboard = this;\n    if(degree !== undefined) {\n      degree = degree[0];\n    } else {\n      degree = 2; // assume degree to be two (default)\n    }\n    \n    let color = this.retrieveConfigProp(pgNode, 'node', 'color');\n    let opacity = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'opacity'));\n    let size = parseFloat(this.retrieveConfigProp(pgNode, 'node', 'size'));\n    let shape = this.retrieveConfigProp(pgNode, 'node', 'shape');\n    \n    color = color || this.nodeColorMap[group];\n    \n    if(opacity < 1) {\n      let rgb = this.getHexColors(color);\n      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;\n    }\n\n    let attrs = {\n      id: pgNode.id,\n      color: color,\n      label: createLabelText(pgNode, props),\n      shape: shape || 'dot',\n      size: size || 25,\n      degree: degree,\n      title: createTitleText(pgNode),\n      fixed: {\n        x: fixed,\n        y: this.config.layout === 'timeline' ? false : fixed\n      },\n      borderWidth: url ? 3 : 1,\n      url: url,\n      x: x,\n      y: y,\n      font: {\n        color: url ? 'blue' : 'black'\n      },\n      fixedByTime: fixed\n    };\n    \n    function iconRegisterer(name) {\n      return (icons) => {\n        if (icons.length > 0) {\n          let icon = null;\n          if(icons.length > 1) {\n            // Find icon with the highest priority \n            for (let prefix of Blitzboard.iconPrefixes) {\n              for (let i of icons) {\n                if (`${i.prefix}:${i.name}`.startsWith(prefix)) {\n                  icon = i; \n                  break;\n                }\n              }\n              if (icon) {\n                break;\n              }\n            }\n          }\n          icon = icon || icons[0];\n          let size = attrs.size * Blitzboard.iconSizeCoef;\n          let svg = Iconify.renderSVG(`${icon.prefix}:${icon.name}`, {\n            width: size,\n            height: size\n          });\n          let img = new Image();\n          // svg.viewBox.baseVal.width = size;\n          // svg.viewBox.baseVal.height = size;\n          svg.querySelectorAll(\"path\").forEach((path) => {\n            path.style.fill = \"white\";\n            path.style.stroke = \"white\";\n          });\n          img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg.outerHTML);\n          Blitzboard.loadedIcons[name] = img;\n          if(blitzboard) {\n            if (blitzboard.redrawTimer) {\n              clearTimeout(blitzboard.redrawTimer);\n            }\n            blitzboard.redrawTimer = setTimeout(() => {  // Add delay to avoid redraw too ofen\n              blitzboard.network.redraw();\n            }, 1000);\n          }\n        }\n      };\n    }\n\n    for(let label of pgNode.labels) {\n      let icon;\n      if (icon = this.config.node.icon?.[label]) {\n        if(icon.includes(':')) { // For icons in iconify\n          Iconify.loadIcons([icon], iconRegisterer(icon));\n          attrs['customIcon'] = {\n            name: icon\n          };\n        } else { // For icon codes in Ionicons (to be backward compatible)\n          let code = String.fromCharCode(parseInt(icon, 16));\n          attrs['customIcon'] = {\n            face: 'Ionicons',\n            size: attrs.size * 1.5,\n            code: code,\n            color: 'white'\n          };\n          break;\n        }\n      }\n    }\n\n\n    if(!attrs['customIcon'] && this.config.node.defaultIcon) {\n      for(let label of pgNode.labels) {\n        let lowerLabel = label.toLowerCase();\n        if (!Blitzboard.loadedIcons[lowerLabel]) {\n          Blitzboard.loadedIcons[lowerLabel] = 'retrieving...'; // Just a placeholder to avoid duplicate fetching\n          Iconify.loadIcons(\n            Blitzboard.iconPrefixes.map((prefix) => prefix + lowerLabel),\n            iconRegisterer(lowerLabel)\n          );\n        }\n      }\n    }\n    \n\n    if(thumbnailUrl) {\n      attrs['shape'] = 'image';\n      attrs['image'] = thumbnailUrl;\n    }\n    attrs = Object.assign(attrs, extraOptions);\n    return attrs;\n  }\n  \n  retrieveConfigProp(pgElem, type, propName) {\n    const labels = pgElem.labels.join('_');\n    let propConfig = this.config?.[type][propName];\n    if((typeof propConfig) === 'function') {\n      return propConfig(new Proxy(pgElem, Blitzboard.blitzProxy));\n    } else if((typeof propConfig) === 'object') {\n      return pgElem.properties[this.config?.[type][propName][labels]]?.[0];\n    } else if((typeof propConfig) === 'string' && propConfig.startsWith('@')) {\n      return pgElem.properties[propConfig.substr(1)]?.[0];\n    }\n    return propConfig; // return as constant\n  }\n\n  toVisEdge(pgEdge, props = this.config.edge.caption, id) {\n    const edgeLabel = pgEdge.labels.join('_');\n    if (!this.edgeColorMap[edgeLabel]) {\n      this.edgeColorMap[edgeLabel] = getRandomColor(edgeLabel, this.config.edge.saturation || '0%', this.config.edge.brightness || '30%');\n    }\n    let length = this.retrieveConfigProp(pgEdge, 'edge','length');\n    let width = parseFloat(this.retrieveConfigProp(pgEdge, 'edge','width')) || 1;\n    let color = this.retrieveConfigProp(pgEdge, 'edge', 'color');\n    let opacity = parseFloat(this.retrieveConfigProp(pgEdge, 'edge', 'opacity')) || 1;\n    \n    color = color || this.edgeColorMap[edgeLabel];\n\n    if(opacity < 1) {\n      let rgb = this.getHexColors(color);\n      color = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${opacity})`;\n    }\n    \n    return {\n      id: id,\n      from: pgEdge.from,\n      to: pgEdge.to,\n      color: color,\n      label: createLabelText(pgEdge, props),\n      title: createTitleText(pgEdge),\n      remoteId: id,\n      length: length,\n      width: width,\n      hoverWidth: 0.5,\n      smooth: this.map ? false : { roundness: 1 },\n      arrows: {\n        to: {\n          enabled: pgEdge.direction == '->' || pgEdge.undirected === 'false'\n        },\n      }\n    }\n  }\n  \n  includesNode(node) {\n    return this.graph.nodes.filter(e => e.id === node.id).length > 0;\n  }\n  \n  addNode(node, update = true) {\n    this.addNodes([node], update);\n  }\n  \n  addNodes(nodes, update = true) {\n    let newNodes;\n    if (typeof nodes === 'string' || nodes instanceof String) {\n      let pg = tryPgParse(nodes);\n      newNodes = pg.nodes;\n    } else {\n      newNodes = nodes;\n    }\n    newNodes = newNodes.filter(node => !this.includesNode(node)).map((node) => {\n      let mapped = deepMerge(Blitzboard.nodeTemplate, node);\n      ++this.maxLine;\n      mapped.location = {\n        start: {\n          line: this.maxLine,\n          column: 0,\n        },\n        end: {\n          line: this.maxLine + 1,\n          column: 0,\n        }\n      }\n      return mapped;\n    });\n    this.graph.nodes = this.graph.nodes.concat(newNodes);\n    for(let callback of this.onNodeAdded) {\n      // TODO: The argument should be proxy instead of plain objects\n      callback(newNodes);\n    }\n    if(update)\n      this.update();\n  }\n  \n  addEdge(edge, update = true) {\n    this.addEdges([edge], update);\n  }\n\n  addEdges(edges, update = true) {\n    let newEdges;\n    if (typeof edges === 'string' || edges instanceof String) {\n      let pg = tryPgParse(edges);\n      newEdges = pg.edges\n    } else {\n      newEdges = edges\n    }\n    newEdges = newEdges.map((edge) => {\n      let mapped = deepMerge(Blitzboard.edgeTemplate, edge);\n      ++this.maxLine;\n      mapped.location = {\n        start: {\n          line: this.maxLine,\n          column: 0, \n        },\n        end: {\n          line: this.maxLine + 1,\n          column: 0,\n        }\n      }\n      return mapped;\n    });\n    this.graph.edges = this.graph.edges.concat(newEdges);\n    for(let callback of this.onEdgeAdded) {\n      // TODO: The argument should be proxy instead of plain objects\n      callback(newEdges);\n    }\n    if(update)\n      this.update();\n  }\n\n\n  setGraph(input, update = true) {\n    this.nodeColorMap = {};\n    this.edgeColorMap = {};\n    this.prevMouseEvent = null;\n    this.dragging = false;\n    let newPg;\n    if (typeof input === 'string' || input instanceof String) {\n      try {\n        newPg = JSON.parse(input);\n      } catch (err) {\n        if (err instanceof SyntaxError)\n          newPg = tryPgParse(input);\n        else\n          throw err;\n      }\n    } else {\n      newPg = input;\n    }\n    if (newPg === null || newPg === undefined)\n      return;\n    this.graph = newPg;\n\n    if(update)\n      this.update();\n  }\n\n\n\n  setConfig(config, update = true) {\n    this.config = deepMerge(Blitzboard.defaultConfig, config);\n    if(config.layout === 'hierarchical') {\n      // Remove redundant settings when layout is hierarchical\n      this.config.layoutSettings = config.layoutSettings;\n    }\n    if(update)\n      this.update(false);\n  }\n  \n  validateGraph() {\n    // If duplication of nodes exist, raise error \n    function nonuniqueNodes(nodes) {\n      let nonunique = new Set();\n      let nodeMap = {} // id -> node\n      for(let node of nodes) {\n        if(nodeMap[node.id]) {\n          nonunique.add(nodeMap[node.id]);\n          nonunique.add(node);\n        }\n        nodeMap[node.id] = node;\n      }\n      return [...nonunique];\n    }\n\n    let nonunique = nonuniqueNodes(this.graph.nodes);\n    if(nonunique.length > 0) {\n      throw new DuplicateNodeError(nonunique);\n    }\n\n    // If edge refers to undefined nodes, create warnings\n    for(let edge of this.graph.edges) {\n      if(!this.nodeMap[edge.from]) {\n        this.warnings.push({\n          location: edge.location,\n          message: `Source node is undefined: ${edge.from}`\n        });\n      }\n      if(!this.nodeMap[edge.to]) {\n        this.warnings.push({\n          location: edge.location,\n          message: `Target node is undefined: ${edge.to}`\n        });\n      }\n    }\n  }\n  \n  update(applyDiff = true) {\n    let blitzboard = this;\n    this.warnings = [];\n    applyDiff = applyDiff && this.nodeDataSet && this.edgeDataSet;\n    if(applyDiff) {\n      let nodesToDelete = new Set(Object.keys(this.nodeMap));\n      let newEdgeMap = {};\n\n      this.nodeLineMap = {};\n      this.edgeLineMap = {};\n      this.maxLine = 0;\n      this.graph.nodes.forEach(node => {\n        let existingNode = this.nodeMap[node.id];\n        if(existingNode) {\n          if(!nodeEquals(node, existingNode)) {\n            this.nodeDataSet.remove(existingNode);\n            let visNode = this.toVisNode(node, this.config.node.caption);\n            this.nodeDataSet.update(visNode);\n          }\n        } else {\n          let visNode = this.toVisNode(node, this.config.node.caption);\n          this.nodeDataSet.add(visNode);\n        }\n        this.nodeMap[node.id] = node;\n        nodesToDelete.delete(node.id);\n        if(node.location) {\n          for (let i = node.location.start.line; i <= node.location.end.line; i++) {\n            if (i < node.location.end.line || node.location.end.column > 1)\n              this.nodeLineMap[i] = node;\n          }\n          this.maxLine = Math.max(this.maxLine, node.location.end.line);\n        }\n      });\n\n      this.graph.edges.forEach(edge => {\n        let id = toNodePairString(edge);\n        while(newEdgeMap[id]) {\n          id += '_';\n        }\n        edge.id = id;\n        newEdgeMap[id] = edge;\n        let visEdge = this.toVisEdge(edge, this.config.edge.caption, id);\n        this.edgeDataSet.update(visEdge);\n        if(edge.location) {\n          for (let i = edge.location.start.line; i <= edge.location.end.line; i++) {\n            if (i < edge.location.end.line || edge.location.end.column > 1)\n              this.edgeLineMap[i] = visEdge;\n          }\n        }\n        this.maxLine = Math.max(this.maxLine, edge.location.end.line);\n      });\n\n      nodesToDelete.forEach((nodeId) => {\n        this.nodeDataSet.remove(this.nodeMap[nodeId]);\n        delete this.nodeMap[nodeId];\n      });\n\n      for(let edgeId of Object.keys(this.edgeMap)) {\n        if(!newEdgeMap[edgeId]) {\n          this.edgeDataSet.remove(edgeId);\n        }\n      }\n      this.edgeMap = newEdgeMap;\n      if(this.map) {\n        blitzboard.updateNodeLocationOnMap();\n      }\n      if(this.config.layout === 'timeline') {\n        blitzboard.updateNodeLocationOnTimeLine();\n      }\n    }\n    \n    this.prevZoomPosition = null;\n    \n    this.minTime = new Date(8640000000000000);\n    this.maxTime = new Date(-8640000000000000);\n    \n    if(this.config.layout === 'timeline') {\n      let fromProp = this.config.layoutSettings.time_from;\n      let toProp = this.config.layoutSettings.time_to;\n      \n      this.graph.nodes.forEach(node => {\n        for (let prop of Object.keys(node.properties)) {\n          if (prop === fromProp || prop === toProp) {\n            this.minTime = new Date(Math.min(this.minTime, new Date(node.properties[prop][0])));\n            this.maxTime = new Date(Math.max(this.maxTime, new Date(node.properties[prop][0])));\n          }\n        }\n      });\n      this.timeInterval = this.maxTime - this.minTime;\n    }\n\n\n    if(applyDiff) {\n      this.validateGraph();\n      return;\n    }\n\n    this.nodeProps = new Set(['id', 'label']);\n    this.edgeProps = new Set(['label']);\n    this.graph.nodes.forEach((node) => {\n      this.nodeMap[node.id] = node;\n      if(node.location) {\n        for (let i = node.location.start.line; i <= node.location.end.line; i++)\n          if (i < node.location.end.line || node.location.end.column > 1)\n            this.nodeLineMap[i] = node;\n      }\n      Object.keys(node.properties).filter((prop) => prop != 'degree').forEach(this.nodeProps.add, this.nodeProps);\n    });\n    this.graph.edges.forEach((edge) => {\n      Object.keys(edge.properties).forEach(this.edgeProps.add, this.edgeProps);\n    });\n\n    this.validateGraph();\n\n\n    let defaultNodeProps = this.config.node.caption;\n    let defaultEdgeProps = this.config.edge.caption;\n\n    this.nodeDataSet = new vis.DataSet();\n    this.nodeDataSet.add(this.graph.nodes.map((node) => {\n      return this.toVisNode(node, defaultNodeProps);\n    }));\n    \n    this.edgeMap = {};\n    this.edgeDataSet = new vis.DataSet(this.graph.edges.map((edge) => {\n      let id = toNodePairString(edge);\n      while(this.edgeMap[id]) {\n        id += '_';\n      }\n      let visEdge = this.toVisEdge(edge, defaultEdgeProps, id);\n      this.edgeMap[visEdge.id] = edge;\n      if(edge.location) {\n        for (let i = edge.location.start.line; i <= edge.location.end.line; i++)\n          if (i < edge.location.end.line || edge.location.end.column > 1)\n            this.edgeLineMap[i] = visEdge;\n      }\n\n      return visEdge;\n    }));\n\n\n\n    // create a network\n    let data = {\n      nodes: this.nodeDataSet,\n      edges: this.edgeDataSet\n    };\n\n    let layout = {\n      randomSeed: 1\n    };\n\n    if(this.config.layout === 'hierarchical') {\n      layout.hierarchical = this.config.layoutSettings;\n    } else {\n      layout.hierarchical = false;\n    }\n\n    this.options = {\n      layout:\n        layout,\n      interaction: {\n        dragNodes: this.config.layout !== 'map',\n        dragView: this.config.layout !== 'map',\n        zoomView: this.config.layout !== 'map',\n        hover: true,\n      },\n      physics: {\n        enabled: this.config.layout !== 'map' && this.config.layout !== 'hierarchical',\n        barnesHut: {\n          springConstant:  this.config.layout === 'timeline' ? 0.004 : 0.016\n        },\n        stabilization: {\n          enabled: false,\n          iterations: 200,\n          updateInterval: 25\n        }\n      },\n      manipulation: false,\n\n      edges: {\n        arrows: {\n          to: {\n            enabled: true,\n            scaleFactor: 0.3,\n            type: \"arrow\"\n          },\n        },\n      },\n    };\n\n    this.options = Object.assign(this.options, this.config.extraOptions);\n    this.network = new vis.Network(this.networkContainer, data, this.options);\n\n    if(this.config.layout === 'map') {\n      this.mapContainer.style.display = 'block';\n      let statistics = statisticsOfMap();\n      let center = this.config?.layoutSettings?.center || statistics.center;\n      if(this.map) {\n        this.map.panTo(center);\n      } else {\n        this.map = L.map(this.mapContainer, {\n          center: center,\n          zoom: statistics.scale,\n          minZoom: 3,\n          zoomSnap: 0.01,\n          zoomControl: false,\n        });\n        var tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n          attribution: '© <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>',\n        });\n        tileLayer.addTo(this.map);\n\n        this.map.on('move', () => blitzboard.updateNodeLocationOnMap());\n        this.map.on('zoom', () => blitzboard.updateNodeLocationOnMap());\n      }\n      blitzboard.network.moveTo({scale: 1.0});\n    } else {\n      this.mapContainer.style.display = 'none';\n      if(this.map) {\n        this.map.remove();\n      }\n      this.map = null;\n    }\n\n\n    this.network.on('resize', (e) => {\n      if(blitzboard.config.layout === 'map') {\n        // Fix scale to 1.0 (delay is needed to override scale set by vis-network)  \n        let newScale = Math.min(Blitzboard.maxScaleOnMap, Math.max(blitzboard.network.getScale(), Blitzboard.minScaleOnMap));\n        setTimeout( () => {\n          blitzboard.network.moveTo({scale: newScale});\n          blitzboard.updateNodeLocationOnMap();\n        }, 10); \n        blitzboard.map.invalidateSize();\n      }\n    });\n    \n\n    this.network.on('dragStart', (e) => {\n      const node = this.nodeDataSet.get(e.nodes[0]);\n      if(e.nodes.length > 0) {\n        this.nodeDataSet.update({\n          id: e.nodes[0],\n          fixed: node.fixedByTime ? {x: true, y: true } : false\n        });\n      }\n    });\n    \n\n    function statisticsOfMap() {\n      let lngKey =  blitzboard.config.layoutSettings.lng;\n      let latKey =  blitzboard.config.layoutSettings.lat;\n      let lngSum = 0, latSum = 0, count = 0,\n        lngMax = Number.MIN_VALUE, lngMin = Number.MAX_VALUE,\n        latMax = Number.MIN_VALUE, latMin = Number.MAX_VALUE;\n      blitzboard.graph.nodes.forEach(node => {\n        if(node.properties[latKey] && node.properties[lngKey]) {\n          let lng = parseFloat(node.properties[lngKey][0]);\n          let lat = parseFloat(node.properties[latKey][0]);\n          lngSum += lng;\n          latSum += lat;\n          lngMax = Math.max(lng, lngMax);\n          lngMin = Math.min(lng, lngMin);\n          latMax = Math.max(lat, latMax);\n          latMin = Math.min(lat, latMin);\n          ++count;\n        }\n      });\n      if(count === 0)\n        return [0, 0];\n      return {\n        center: [latSum / count, lngSum / count],\n        scale: Math.max( -Math.log2(Math.max(Math.abs(lngMax - lngMin), Math.abs(latMax - latMin)) / 1000), 0)\n      };\n    }\n\n    \n    this.network.on(\"zoom\", function(){\n      let pos = blitzboard.network.getViewPosition();\n      if(blitzboard.config.zoom?.min && blitzboard.network.getScale() < blitzboard.config.zoom.min)\n      {\n        blitzboard.network.moveTo({\n          position: blitzboard.prevZoomPosition,\n          scale: blitzboard.config.zoom?.min\n        });\n      }\n      else if(blitzboard.config.zoom?.max && blitzboard.network.getScale() > blitzboard.config.zoom.max){\n        blitzboard.network.moveTo({\n          position: blitzboard.prevZoomPosition,\n          scale: blitzboard.config.zoom.max,\n        });\n      } else {\n        blitzboard.prevZoomPosition = pos;\n      }\n    });\n    \n    if(this.map) {\n      this.updateNodeLocationOnMap();\n    }\n    \n    this.network.on(\"hoverNode\", (e) => {\n      this.network.canvas.body.container.style.cursor = 'default';\n      const node = this.nodeDataSet.get(e.node);\n      if(node && node.url) {\n        this.network.canvas.body.container.style.cursor = 'pointer';\n        this.nodeDataSet.update({\n          id: e.node,\n          color: '#8888ff',\n        });\n        if(this.config.node.onHover) {\n          this.config.node.onHover(this.getNode(e.node));\n        }\n      } else if(node && node.degree > 1 && !this.expandedNodes.includes(e.node)) {\n        this.network.canvas.body.container.style.cursor = 'pointer';\n      }\n    });\n\n    function plotTimes(startTime, interval, intervalUnit, timeForOnePixel, offsetX, offsetY, rightMostX, context, scale) {\n      let currentTime = new Date(startTime);\n      switch(intervalUnit) {\n        case 'year':\n          currentTime = new Date(currentTime.getFullYear()  - currentTime.getFullYear() % interval, 0, 1);\n          break;\n        case 'month':\n          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth() - currentTime.getMonth() % interval, 1);\n          break;\n        case 'day':\n          currentTime = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate());\n          break;\n        default:\n          return;\n      }\n      let i = 0;\n      while(++i < 100) {\n        const nextPosition = -offsetX + (currentTime - startTime) / timeForOnePixel;\n        if(nextPosition > rightMostX) break;\n        if(intervalUnit === 'year')\n          context.fillText(currentTime.getFullYear(), nextPosition, -offsetY);\n        else\n          context.fillText(currentTime.toLocaleDateString(), nextPosition, -offsetY);\n        context.moveTo(nextPosition, -offsetY);\n        context.lineTo(nextPosition, -offsetY + 25 / scale);\n        context.stroke();\n        switch(intervalUnit) {\n          case 'year':\n            currentTime.setFullYear(currentTime.getFullYear() + interval);\n            break;\n          case 'month':\n            currentTime.setMonth(currentTime.getMonth() + interval);\n            break;\n          case 'day':\n            currentTime.setDate(currentTime.getDate() + interval);\n            break;\n          default:\n            return;\n        }\n      }\n    }\n    \n    this.network.on(\"afterDrawing\", (ctx) => {\n      for(let node of this.graph.nodes) {\n        node = this.nodeDataSet.get(node.id);\n        if(node && node.shape !== 'image' && (node.customIcon || this.config.node.defaultIcon)) {\n          let position = this.network.getPosition(node.id);\n          let pgNode = this.nodeMap[node.id];\n          if(node.customIcon) {\n            if(node.customIcon.name && Blitzboard.loadedIcons[node.customIcon.name]) { // Iconiy\n              ctx.drawImage(Blitzboard.loadedIcons[node.customIcon.name],\n                position.x - node.size * Blitzboard.iconSizeCoef / 2, position.y - node.size * Blitzboard.iconSizeCoef / 2,\n                node.size * Blitzboard.iconSizeCoef, \n                node.size * Blitzboard.iconSizeCoef);\n            } else { // Ionicons\n              ctx.font = `${node.customIcon.size}px Ionicons`;\n              ctx.fillStyle = \"white\";\n              ctx.textAlign = \"center\";\n              ctx.textBaseline = \"middle\";\n              ctx.fillText(node.customIcon.code, position.x, position.y);\n            }\n          } else {\n            if(!pgNode) {\n              continue;\n            }\n            for (let label of pgNode.labels) {\n              let lowerLabel = label.toLowerCase();\n              if (Blitzboard.loadedIcons[lowerLabel]) {\n                if(Blitzboard.loadedIcons[lowerLabel] != 'retrieving...')\n                  ctx.drawImage(Blitzboard.loadedIcons[lowerLabel], position.x - node.size * Blitzboard.iconSizeCoef / 2,\n                    position.y - node.size * Blitzboard.iconSizeCoef / 2,\n                    node.size * Blitzboard.iconSizeCoef,\n                    node.size * Blitzboard.iconSizeCoef);\n                break;\n              }\n            }\n          }\n        }\n      }\n\n     if(this.config.layout === 'timeline'){\n        const context = this.network.canvas.getContext(\"2d\");\n        const view = this.network.canvas.body.view;\n        const offsetY = (view.translation.y - 20) / view.scale;\n        const offsetX = view.translation.x / view.scale;\n        const timeForOnePixel = (this.maxTime - this.minTime) / this.timeScale;\n        const timeOnLeftEdge = new Date(((this.maxTime.getTime() + this.minTime.getTime()) / 2) - timeForOnePixel * offsetX);\n        const clientWidth = this.network.canvas.body.container.clientWidth;\n        const rightMost = -offsetX + clientWidth / view.scale;\n        const oneMonth = 31 * 24 * 60 * 60 * 1000;\n        const oneDay = 24 * 60 * 60 * 1000;\n        const twoMonth = oneMonth * 2;\n        const fourMonth = twoMonth * 2;\n        const oneYear = 365 * oneDay;\n        const minDistance = 200;\n        context.font = (20 / view.scale).toString() + \"px Arial\";\n        context.fillStyle = \"blue\";\n        const minimumInterval = timeForOnePixel * minDistance / view.scale;\n        if(minimumInterval > oneYear ) {\n          plotTimes(timeOnLeftEdge, minimumInterval / oneYear, 'year', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        }\n        else if(minimumInterval > fourMonth ) {\n          plotTimes(timeOnLeftEdge, 4, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        }\n        else if(minimumInterval > twoMonth) {\n          plotTimes(timeOnLeftEdge, 2, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        }\n        else if(minimumInterval > oneMonth) {\n          plotTimes(timeOnLeftEdge, 1, 'month', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        } else if(minimumInterval > oneDay * 16) {\n          plotTimes(timeOnLeftEdge, 16, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        } else if(minimumInterval > oneDay * 8) {\n          plotTimes(timeOnLeftEdge, 8, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        } else if(minimumInterval > oneDay * 4) {\n          plotTimes(timeOnLeftEdge, 4, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        } else if(minimumInterval > oneDay * 2) {\n          plotTimes(timeOnLeftEdge, 2, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        } else {\n          plotTimes(timeOnLeftEdge, 1, 'day', timeForOnePixel, offsetX, offsetY, rightMost, context, view.scale);\n        }\n      }\n    });\n    this.network.on(\"blurNode\", (params) => {\n      this.network.canvas.body.container.style.cursor = 'default';\n      let node = this.nodeDataSet.get(params.node);\n      if(node && node.url) {\n        this.nodeDataSet.update({\n          id: params.node,\n          color: null,\n        });\n      }\n    });\n\n    if (!Blitzboard.fondLoaded && document.fonts) {\n      Blitzboard.fondLoaded = true;\n      let blitzboard = this;\n      // Decent browsers: Make sure the fonts are loaded.\n      document.fonts.load('normal normal 400 24px/1 \"FontAwesome\"')\n        .catch(\n          console.error.bind(console, \"Failed to load Font Awesome 4.\")\n        ).then(function () {\n        blitzboard.network.redraw();\n      })\n        .catch(\n          console.error.bind(\n            console,\n            \"Failed to render the network with Font Awesome 4.\"\n          )\n        );\n    }\n\n    function clickHandler(e) {\n      blitzboard.doubleClickTimer = null;\n      if (e.nodes.length > 0) {\n        if (blitzboard.config.node.onClick) {\n          blitzboard.config.node.onClick(blitzboard.getNode(e.nodes[0]));\n        }\n      } else if (e.edges.length > 0) {\n        if (blitzboard.config.edge.onClick) {\n          blitzboard.config.edge.onClick(blitzboard.getEdge(e.edges[0]));\n        }\n      }\n    }\n\n    this.network.on(\"click\", (e) => {\n      if(!this.doubleClickTimer) {\n        if (this.config.doubleClickWait <= 0) {\n          clickHandler(e);\n        } else {\n          this.doubleClickTimer = setTimeout(() => clickHandler(e), this.config.doubleClickWait);\n        }\n      }\n    });\n\n    \n    this.network.on(\"doubleClick\", (e) => {\n      clearTimeout(this.doubleClickTimer);\n      this.doubleClickTimer = null;\n      if(e.nodes.length > 0) {\n        if(this.config.node.onDoubleClick) {\n          this.config.node.onDoubleClick(this.getNode(e.nodes[0]));\n        }\n      } else if(e.edges.length > 0) {\n        if(this.config.edge.onDoubleClick) {\n          this.config.edge.onDoubleClick(this.getEdge(e.edges[0]));\n        }\n      }\n    });\n  }\n\n\n  scrollNodeIntoView(node, select = true) {\n    if(typeof(node) === 'string')\n      node = this.nodeMap[node];\n    if(!node)\n      return;\n\n    if(this.config.layout === 'map') {\n      this.scrollMapToNode(this.nodeMap[node.id]);\n    } else {\n      this.scrollNetworkToPosition(this.network.getPosition(node.id));\n    }\n    if(select)\n      this.network.selectNodes([node.id]);\n\n    for(let callback of this.onNodeFocused) {\n      // TODO: The argument should be proxy instead of plain objects\n      callback(node);\n    }\n  }\n  \n  scrollNetworkToPosition(position) {\n    clearTimeout(this.scrollAnimationTimerId);\n    this.scrollAnimationTimerId = setTimeout(() => {\n      const animationOption = {\n        scale: 1.0,\n        animation:\n          {\n            duration: 500,\n            easingFuntcion: \"easeInOutQuad\"\n          }\n      };\n      this.network.moveTo({ ...{position: position}, ...animationOption });\n    }, 200); // Set delay to avoid calling moveTo() too much (seem to cause some bug on animation)\n  }\n  \n  updateNodeLocationOnMap() {\n    let nodePositions = [];\n    let lngKey =  this.config.layoutSettings.lng;\n    let latKey =  this.config.layoutSettings.lat;\n    this.graph.nodes.forEach(node => {\n      if(node.properties[latKey] && node.properties[lngKey]) {\n        let point = this.map.latLngToContainerPoint([node.properties[latKey][0], node.properties[lngKey][0]]);\n        point = this.network.DOMtoCanvas(point);\n        nodePositions.push({\n          id: node.id,\n          x: point.x, y: point.y, fixed: true\n        });\n      }\n    });\n    this.nodeDataSet.update(nodePositions);\n  }\n\n\n  updateNodeLocationOnTimeLine() {\n    let nodePositions = [];\n    this.graph.nodes.forEach(node => {\n      let x, y, fixed, width;\n      ({x, y, fixed, width} = this.calcNodePosition(node));\n      nodePositions.push({\n        id: node.id,\n        x, y\n      });\n    });\n    this.nodeDataSet.update(nodePositions);\n  }\n  \n  scrollMapToNode(node) {\n    let lngKey = this.config.layoutSettings.lng;\n    let latKey = this.config.layoutSettings.lat;\n    this.map.panTo([node.properties[latKey][0] ,node.properties[lngKey][0]]);\n  }\n  \n  scrollEdgeIntoView(edge, select = true) {\n    if(typeof(edge) === 'string') {\n      edge = this.edgeMap[edge];\n    }\n\n    if(this.config.layout === 'map') {\n      this.scrollMapToNode(this.nodeMap[edge.from]);\n    } else {\n      const from = this.network.getPosition(edge.from);\n      const to = this.network.getPosition(edge.to);\n      this.scrollNetworkToPosition({ x: (from.x + to.x) / 2, y: (from.y + to.y) /2 });\n    }\n    if(select) {\n      blitzboard.network.selectEdges([edge.id]);\n    }\n\n    for(let callback of this.onEdgeFocused) {\n      // TODO: The argument should be proxy instead of plain objects\n      callback(edge);\n    }\n  }\n  \n  showLoader(text = \"Now loading...\") {\n    this.screen.style.display = 'flex';\n    this.screenText.innerText = text;\n    this.screenText.style.display = text ? 'block' : 'none';\n  }\n  \n  hideLoader() {\n    this.screen.style.display = 'none';\n  }\n}\n\nlet markers = [];\nlet nodeProps, edgeProps;\n\nfunction arrayEquals(a, b) {\n  return Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index]);\n}\n\nfunction nodeEquals(node1, node2) {\n  if(node1.id != node2.id || !arrayEquals(node1.labels, node2.labels)) {\n    return false;\n  }\n  let node1Keys = Object.keys(node1.properties);\n  let node2Keys = Object.keys(node2.properties);\n  if(node1Keys.length != node2Keys.length) {\n    return false;\n  }\n  for(let key of node1Keys) {\n    if(!arrayEquals(node1.properties[key], node2.properties[key]))\n      return false;\n  }\n  return true;\n}\n\n\nfunction deepMerge(target, source) {\n  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);\n  let result = Object.assign({}, target);\n  if (isObject(target) && isObject(source)) {\n    for (const [sourceKey, sourceValue] of Object.entries(source)) {\n      const targetValue = target[sourceKey];\n      if (isObject(sourceValue) && target.hasOwnProperty(sourceKey)) {\n        result[sourceKey] = deepMerge(targetValue, sourceValue);\n      }\n      else {\n        Object.assign(result, {[sourceKey]: sourceValue});\n      }\n    }\n  }\n  return result;\n}\n\nfunction retrieveHttpUrl(node) {\n  let candidates = [];\n  for(let entry of Object.entries(node.properties)) {\n    for(let prop of entry[1]) {\n      if(typeof(prop) === 'string' && (prop.startsWith(\"https://\") || prop.startsWith(\"http://\"))) {\n        if(entry[0].toLowerCase() == 'url')\n          return prop;\n        candidates.push([entry[0], prop]);\n      }\n    }\n  }\n  return candidates[0];\n}\n\n\nfunction toNodePairString(pgEdge) {\n  return `${pgEdge.from}-${pgEdge.to}`;\n}\n\n\nfunction wrapText(str, asHtml) {\n  if(!str)\n    return str;\n  if(Array.isArray(str))\n    str = str[0];\n  const maxWidth = 40;\n  let newLineStr = asHtml ? \"<br>\" : \"\\n\", res = '';\n  while (str.length > maxWidth) {\n    res += str.slice(0, maxWidth) + newLineStr;\n    str = str.slice(maxWidth);\n  }\n  return res + str;\n}\n\nfunction createLabelText(elem, props = null) {\n  if (props != null) {\n    // Use whitespace instead of empty string if no props are specified because Vis.js cannot update label with empty string)\n    return props.length ? props.map((prop) => prop === 'id' ? elem.id : (prop === 'label' ? elem.labels : wrapText(elem.properties[prop]))).filter((val) => val).join('\\n') : ' ';\n  }\n}\n\nfunction createTitleText(elem) {\n  let flattend_props = Object.entries(elem.properties).reduce((acc, prop) =>\n    acc.concat(`<tr valign=\"top\"><td>${prop[0]}</td><td> : ${wrapText(prop[1], true)}</td></tr>`), []);\n  if (elem.id) // for nodes\n  {\n    let idText = `<tr><td><b>${elem.id}</b></td><td> : ${wrapText(elem.labels.join(':'), true)}</td></tr>`;\n    flattend_props.splice(0, 0, idText);\n  }\n  if (flattend_props.length === 0) {\n    return null;\n  }\n  return htmlTitle(`<table style='fixed'>${flattend_props.join('')}</table>`);\n}\n\n// Create random colors, with str as seed, and with fixed saturation and lightness\nfunction getRandomColor(str, saturation, brightness) {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    hash = str.charCodeAt(i) + ((hash << 5) - hash);\n    hash = hash & hash;\n  }\n  let hue = hash % 360;\n  return 'hsl(' + hue + `, ${saturation}, ${brightness})`;\n}\n\nfunction setSearchState(searching) {\n  const icon =  q('#search-icon');\n  if(searching) {\n    icon.classList.remove(\"fa-search\");\n    icon.classList.add(\"fa-spinner\");\n    icon.classList.add(\"fa-spin\");\n  } else {\n    icon.classList.add(\"fa-search\");\n    icon.classList.remove(\"fa-spinner\");\n    icon.classList.remove(\"fa-spin\");\n  }\n}\n\nfunction isDateString(str) {\n  return isNaN(str) && !isNaN(Date.parse(str))\n}\n\nfunction tryPgParse(pg) {\n  for(let marker of markers)\n    marker.clear();\n  markers = [];\n  try {\n    return pgParser.parse(pg);\n  } catch(e) {\n    console.log(e);\n    if (!e.hasOwnProperty('location'))\n      throw(e);\n    let loc = e.location;\n    // Mark leading characters in the error line\n    markers.push(editor.markText({line: loc.start.line - 1, ch: 0}, {line: loc.start.line - 1, ch: loc.start.column - 1}, {className: 'syntax-error-line', message: e.message}));\n    markers.push(editor.markText({line: loc.start.line - 1, ch: loc.start.column - 1}, {line: loc.end.line - 1, ch: loc.end.column - 1}, {className: 'syntax-error', message: e.message}));\n    // Mark following characters in the error line\n    markers.push(editor.markText({line: loc.end.line - 1, ch: loc.end.column - 1}, {line: loc.end.line - 1, ch: 10000},\n      {className: 'syntax-error-line', message: e.message}));\n    toastr.error(e.message, 'PG SyntaxError', {preventDuplicates: true})\n    return null;\n  }\n}\n\nfunction htmlTitle(html) {\n  const container = document.createElement(\"div\");\n  container.innerHTML = html;\n  return container;\n}\n\n",{"ruleId":"57","severity":2,"message":"58","line":55,"column":5,"nodeType":"59","endLine":55,"endColumn":15},{"ruleId":"60","severity":2,"message":"61","line":4,"column":7,"nodeType":"62","messageId":"63","endLine":4,"endColumn":9},{"ruleId":"60","severity":2,"message":"64","line":14,"column":7,"nodeType":"62","messageId":"63","endLine":14,"endColumn":17},{"ruleId":"60","severity":2,"message":"65","line":170,"column":50,"nodeType":"62","messageId":"63","endLine":170,"endColumn":51},{"ruleId":"60","severity":2,"message":"65","line":175,"column":49,"nodeType":"62","messageId":"63","endLine":175,"endColumn":50},{"ruleId":"60","severity":2,"message":"66","line":315,"column":20,"nodeType":"62","messageId":"63","endLine":315,"endColumn":25},{"ruleId":"60","severity":2,"message":"67","line":319,"column":9,"nodeType":"62","messageId":"63","endLine":319,"endColumn":17},{"ruleId":"68","severity":2,"message":"69","line":383,"column":21,"nodeType":"62","messageId":"70","endLine":383,"endColumn":28},{"ruleId":"71","severity":2,"message":"72","line":410,"column":11,"nodeType":"73","messageId":"74","endLine":410,"endColumn":48},{"ruleId":"68","severity":2,"message":"69","line":412,"column":11,"nodeType":"62","messageId":"70","endLine":412,"endColumn":18},{"ruleId":"68","severity":2,"message":"69","line":435,"column":11,"nodeType":"62","messageId":"70","endLine":435,"endColumn":18},{"ruleId":"68","severity":2,"message":"75","line":772,"column":28,"nodeType":"62","messageId":"70","endLine":772,"endColumn":31},{"ruleId":"68","severity":2,"message":"75","line":778,"column":28,"nodeType":"62","messageId":"70","endLine":778,"endColumn":31},{"ruleId":"68","severity":2,"message":"75","line":846,"column":24,"nodeType":"62","messageId":"70","endLine":846,"endColumn":27},{"ruleId":"68","severity":2,"message":"76","line":855,"column":20,"nodeType":"62","messageId":"70","endLine":855,"endColumn":21},{"ruleId":"68","severity":2,"message":"76","line":862,"column":25,"nodeType":"62","messageId":"70","endLine":862,"endColumn":26},{"ruleId":"60","severity":2,"message":"65","line":880,"column":32,"nodeType":"62","messageId":"63","endLine":880,"endColumn":33},{"ruleId":"60","severity":2,"message":"77","line":1220,"column":15,"nodeType":"62","messageId":"63","endLine":1220,"endColumn":20},{"ruleId":"60","severity":2,"message":"66","line":1220,"column":22,"nodeType":"62","messageId":"63","endLine":1220,"endColumn":27},{"ruleId":"68","severity":2,"message":"78","line":1248,"column":7,"nodeType":"62","messageId":"70","endLine":1248,"endColumn":17},{"ruleId":"60","severity":2,"message":"79","line":1269,"column":5,"nodeType":"62","messageId":"63","endLine":1269,"endColumn":14},{"ruleId":"60","severity":2,"message":"80","line":1269,"column":16,"nodeType":"62","messageId":"63","endLine":1269,"endColumn":25},{"ruleId":"81","severity":2,"message":"82","line":1301,"column":43,"nodeType":"83","messageId":"84","endLine":1301,"endColumn":57},{"ruleId":"60","severity":2,"message":"85","line":1378,"column":10,"nodeType":"62","messageId":"63","endLine":1378,"endColumn":24},{"ruleId":"60","severity":2,"message":"86","line":1391,"column":10,"nodeType":"62","messageId":"63","endLine":1391,"endColumn":22},{"ruleId":"68","severity":2,"message":"87","line":1400,"column":12,"nodeType":"62","messageId":"70","endLine":1400,"endColumn":20},{"ruleId":"81","severity":2,"message":"82","line":1403,"column":12,"nodeType":"83","messageId":"84","endLine":1403,"endColumn":26},{"ruleId":"68","severity":2,"message":"88","line":1407,"column":18,"nodeType":"62","messageId":"70","endLine":1407,"endColumn":24},{"ruleId":"68","severity":2,"message":"88","line":1408,"column":18,"nodeType":"62","messageId":"70","endLine":1408,"endColumn":24},{"ruleId":"68","severity":2,"message":"88","line":1410,"column":18,"nodeType":"62","messageId":"70","endLine":1410,"endColumn":24},{"ruleId":"68","severity":2,"message":"89","line":1412,"column":5,"nodeType":"62","messageId":"70","endLine":1412,"endColumn":11},"vue/no-unused-components","The \"Blitzboard\" component has been registered but not used.","Property","no-unused-vars","'qa' is assigned a value but never used.","Identifier","unusedVar","'Blitzboard' is defined but never used.","'e' is defined but never used.","'width' is assigned a value but never used.","'expanded' is assigned a value but never used.","no-undef","'Iconify' is not defined.","undef","no-cond-assign","Expected a conditional expression and instead saw an assignment.","AssignmentExpression","missing","'vis' is not defined.","'L' is not defined.","'fixed' is assigned a value but never used.","'blitzboard' is not defined.","'nodeProps' is defined but never used.","'edgeProps' is defined but never used.","no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","'setSearchState' is defined but never used.","'isDateString' is defined but never used.","'pgParser' is not defined.","'editor' is not defined.","'toastr' is not defined."]